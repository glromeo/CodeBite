"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.configure = exports.defaultOptions = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const tiny_node_logger_1 = __importDefault(require("tiny-node-logger"));
function loadConfig(pathname) {
    try {
        return require(path_1.default.resolve(pathname));
    }
    catch (error) {
        throw new Error(`Unable to load config '${pathname}' from '${process.cwd()}', ${error.message}`);
    }
}
function resolveConfig(pathname) {
    try {
        return require.resolve(path_1.default.resolve(pathname));
    }
    catch (ignored) {
        return null;
    }
}
function assignConfig(target, source) {
    if (source !== undefined && source !== null) {
        if (target instanceof Array && source instanceof Array) {
            const merged = new Set(target);
            for (const item of source) {
                merged.add(item);
            }
            target.length = 0;
            target.push(...merged);
        }
        else if (target instanceof Object && source instanceof Object) {
            for (const [k, v] of Object.entries(source)) {
                if (target[k] && (v.constructor === Object || v.constructor === Array)) {
                    assignConfig(target[k], v);
                }
                else {
                    target[k] = v;
                }
            }
        }
    }
}
function loadPlugin(module) {
    try {
        return require(`${module}/esnext-server.plugin`);
    }
    catch (error) {
        tiny_node_logger_1.default.error("plugin", module, "load failed", error);
        throw new Error(`Unable to load plugin '${module}' from '${process.cwd()}'`);
    }
}
function statDirectory(pathname) {
    try {
        return fs_1.default.statSync(pathname);
    }
    catch (ignored) {
        throw new Error(`ENOENT: no such file or directory '${pathname}'`);
    }
}
function resolveDirectory(name) {
    const pathname = path_1.default.resolve(name);
    if (!statDirectory(pathname).isDirectory()) {
        throw new Error(`ENODIR: not a directory '${pathname}'`);
    }
    return pathname;
}
function defaultOptions(args) {
    const baseDir = path_1.default.resolve(__dirname, "..");
    const rootDir = args.root ? resolveDirectory(args.root) : process.cwd();
    const readTextFileSync = (filename) => {
        try {
            return fs_1.default.readFileSync(path_1.default.resolve(rootDir, filename), "utf-8");
        }
        catch (ignored) {
            return fs_1.default.readFileSync(path_1.default.resolve(baseDir, filename), "utf-8");
        }
    };
    return Object.assign({
        rootDir,
        log: {
            level: "info"
        },
        http2: "push",
        server: {
            protocol: "https",
            host: "localhost",
            port: 3000,
            options: {
                get key() {
                    return readTextFileSync("cert/localhost.key");
                },
                get cert() {
                    return readTextFileSync("cert/localhost.crt");
                },
                allowHTTP1: true
            }
        },
        resources: path_1.default.resolve(baseDir, "resources"),
        watcher: {
            cwd: rootDir,
            atomic: false,
            ignored: [
                "node_modules/**",
                "web_modules/**"
            ]
        },
        router: {
            ignoreTrailingSlash: true,
            allowUnsafeRegex: true
        },
        middleware: [],
        proxy: {
            "/api": { target: "http://localhost:9000" }
        },
        cors: {
            origin: "*",
            methods: "GET, HEAD, PUT, POST, DELETE, PATCH",
            allowedHeaders: "X-Requested-With, Accept, Content-Type",
            credentials: true
        },
        cache: true,
        deflate: true,
        etag: {
            weak: false
        },
        mount: {
            "/": rootDir
        },
        babel: {
            babelrc: true,
            caller: {
                name: "esnext-server",
                supportsStaticESM: true
            },
            sourceType: "module",
            sourceMaps: true,
            plugins: [
                ["@babel/plugin-syntax-import-meta"],
                ["@babel/plugin-transform-runtime", {
                        "corejs": false,
                        "helpers": true,
                        "regenerator": false,
                        "useESModules": true,
                        "absoluteRuntime": false,
                        "version": "7.10.5"
                    }]
            ]
        },
        sass: {
            extensions: [".scss", ".css", ".sass"],
            outputStyle: "expanded"
        }
    }, require("esnext-web-modules/web-modules.config.js"));
}
exports.defaultOptions = defaultOptions;
function configure(args = {}, override) {
    let options = defaultOptions(args);
    if (args.config) {
        assignConfig(options, loadConfig(args.config));
    }
    else {
        const rootConfig = resolveConfig(path_1.default.join(options.rootDir, "esnext-server.config"));
        const localConfig = resolveConfig("esnext-server.config");
        if (rootConfig) {
            if (localConfig !== rootConfig) {
                assignConfig(options, loadConfig(rootConfig));
            }
        }
        else {
            tiny_node_logger_1.default.debug(`no config found in '${options.rootDir}'`);
        }
        if (localConfig) {
            assignConfig(options, loadConfig(localConfig));
        }
        else {
            tiny_node_logger_1.default.debug(`no config found in '${process.cwd()}'`);
        }
    }
    if (override) {
        assignConfig(options, override);
    }
    if (args.module) {
        const modules = Array.isArray(args.module) ? args.module : [args.module];
        for (const module of modules) {
            assignConfig(options, loadPlugin(module));
        }
    }
    if (options.log) {
        Object.assign(tiny_node_logger_1.default, options.log);
    }
    if (args.debug) {
        tiny_node_logger_1.default.level = "debug";
    }
    tiny_node_logger_1.default.debug("configured:", options);
    return options;
}
exports.configure = configure;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uZmlndXJlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2NvbmZpZ3VyZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFNQSw0Q0FBb0I7QUFHcEIsZ0RBQXdCO0FBQ3hCLHdFQUFtQztBQW9DbkMsU0FBUyxVQUFVLENBQUMsUUFBZ0I7SUFDaEMsSUFBSTtRQUNBLE9BQU8sT0FBTyxDQUFDLGNBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztLQUMxQztJQUFDLE9BQU8sS0FBSyxFQUFFO1FBQ1osTUFBTSxJQUFJLEtBQUssQ0FBQywwQkFBMEIsUUFBUSxXQUFXLE9BQU8sQ0FBQyxHQUFHLEVBQUUsTUFBTSxLQUFLLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztLQUNwRztBQUNMLENBQUM7QUFFRCxTQUFTLGFBQWEsQ0FBQyxRQUFnQjtJQUNuQyxJQUFJO1FBQ0EsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDLGNBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztLQUNsRDtJQUFDLE9BQU8sT0FBTyxFQUFFO1FBQ2QsT0FBTyxJQUFJLENBQUM7S0FDZjtBQUNMLENBQUM7QUFFRCxTQUFTLFlBQVksQ0FBSSxNQUFTLEVBQUUsTUFBVztJQUMzQyxJQUFJLE1BQU0sS0FBSyxTQUFTLElBQUksTUFBTSxLQUFLLElBQUksRUFBRTtRQUN6QyxJQUFJLE1BQU0sWUFBWSxLQUFLLElBQUksTUFBTSxZQUFZLEtBQUssRUFBRTtZQUNwRCxNQUFNLE1BQU0sR0FBRyxJQUFJLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUMvQixLQUFLLE1BQU0sSUFBSSxJQUFJLE1BQU0sRUFBRTtnQkFDdkIsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUNwQjtZQUNELE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1lBQ2xCLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxNQUFN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YUFBTTtZQUNILDBCQUFHLENBQUMsS0FBSyxDQUFDLHVCQUF1QixPQUFPLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1NBQ3REO0tBQ0o7SUFFRCxJQUFJLFFBQVEsRUFBRTtRQUNWLFlBQVksQ0FBQyxPQUFPLEVBQUUsUUFBUSxDQUFDLENBQUM7S0FDbkM7SUFFRCxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7UUFDYixNQUFNLE9BQU8sR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDekUsS0FBSyxNQUFNLE1BQU0sSUFBSSxPQUFPLEVBQUU7WUFDMUIsWUFBWSxDQUFDLE9BQU8sRUFBRSxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztTQUM3QztLQUNKO0lBRUQsSUFBSSxPQUFPLENBQUMsR0FBRyxFQUFFO1FBQ2IsTUFBTSxDQUFDLE1BQU0sQ0FBQywwQkFBRyxFQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUNuQztJQUVELElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtRQUNaLDBCQUFHLENBQUMsS0FBSyxHQUFHLE9BQU8sQ0FBQztLQUN2QjtJQUVELDBCQUFHLENBQUMsS0FBSyxDQUFDLGFBQWEsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUVsQyxPQUFPLE9BQU8sQ0FBQztBQUNuQixDQUFDO0FBN0NELDhCQTZDQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7VHJhbnNmb3JtT3B0aW9uc30gZnJvbSBcIkBiYWJlbC9jb3JlXCI7XG5pbXBvcnQge0ZTV2F0Y2hlciwgV2F0Y2hPcHRpb25zfSBmcm9tIFwiY2hva2lkYXJcIjtcbmltcG9ydCB7Q29yc09wdGlvbnN9IGZyb20gXCJjb3JzXCI7XG5pbXBvcnQge1dlYk1vZHVsZXNPcHRpb25zfSBmcm9tIFwiZXNuZXh0LXdlYi1tb2R1bGVzXCI7XG5pbXBvcnQge09wdGlvbnN9IGZyb20gXCJldGFnXCI7XG5pbXBvcnQgUm91dGVyLCB7SFRUUFZlcnNpb259IGZyb20gXCJmaW5kLW15LXdheVwiO1xuaW1wb3J0IGZzIGZyb20gXCJmc1wiO1xuaW1wb3J0IFNlcnZlciBmcm9tIFwiaHR0cC1wcm94eVwiO1xuaW1wb3J0IHtTeW5jT3B0aW9uc30gZnJvbSBcIm5vZGUtc2Fzc1wiO1xuaW1wb3J0IHBhdGggZnJvbSBcInBhdGhcIjtcbmltcG9ydCBsb2cgZnJvbSBcInRpbnktbm9kZS1sb2dnZXJcIjtcbmltcG9ydCB7U2VydmVyT3B0aW9uc30gZnJvbSBcIi4vc2VydmVyXCI7XG5cbmV4cG9ydCB0eXBlIEZpbmRNeVdheU1pZGRsZXdhcmUgPSAoXG4gICAgcm91dGVyOiBSb3V0ZXIuSW5zdGFuY2U8SFRUUFZlcnNpb24uVjEgfCBIVFRQVmVyc2lvbi5WMj4sXG4gICAgb3B0aW9uczogRVNOZXh0T3B0aW9ucyxcbiAgICB3YXRjaGVyOiBGU1dhdGNoZXJcbikgPT4gdm9pZDtcblxuZXhwb3J0IHR5cGUgRVNOZXh0T3B0aW9ucyA9IFdlYk1vZHVsZXNPcHRpb25zICYge1xuICAgIHJvb3REaXI6IHN0cmluZ1xuICAgIGxvZz86IHtcbiAgICAgICAgbGV2ZWw6IFwidHJhY2VcIiB8IFwiZGVidWdcIiB8IFwiaW5mb1wiIHwgXCJ3YXJuXCIgfCBcImVycm9yXCIgfCBcIm5vdGhpbmdcIlxuICAgICAgICBkZXRhaWxzPzogYm9vbGVhblxuICAgICAgICBjb21wYWN0PzogYm9vbGVhblxuICAgIH1cbiAgICBodHRwMj86IFwicHVzaFwiIHwgXCJwcmVsb2FkXCIgfCBmYWxzZVxuICAgIHNlcnZlcj86IFNlcnZlck9wdGlvbnNcbiAgICByZXNvdXJjZXM6IHN0cmluZ1xuICAgIHdhdGNoZXI/OiBXYXRjaE9wdGlvbnNcbiAgICByb3V0ZXI6IFJvdXRlci5Db25maWc8SFRUUFZlcnNpb24uVjEgfCBIVFRQVmVyc2lvbi5WMj5cbiAgICBtaWRkbGV3YXJlOiBGaW5kTXlXYXlNaWRkbGV3YXJlW11cbiAgICBwcm94eTogeyBbcGF0aDogc3RyaW5nXTogU2VydmVyLlNlcnZlck9wdGlvbnMgfVxuICAgIGNvcnM6IENvcnNPcHRpb25zXG4gICAgZXRhZzogT3B0aW9uc1xuICAgIGNhY2hlPzogYm9vbGVhblxuICAgIGVuY29kaW5nOiBcImd6aXBcIiB8IFwiYnJvdGxpXCIgfCBcImJyXCIgfCBcImRlZmxhdGVcIiB8IFwiZGVmbGF0ZS1yYXdcIiB8IHVuZGVmaW5lZFxuICAgIHRyYW5zZm9ybToge1xuICAgICAgICBpbmNsdWRlOiBzdHJpbmcgfCBzdHJpbmdbXVxuICAgICAgICBleGNsdWRlOiBzdHJpbmcgfCBzdHJpbmdbXVxuICAgIH1cbiAgICBtb3VudDogeyBbcGF0aDogc3RyaW5nXTogc3RyaW5nIH1cbiAgICBiYWJlbDogVHJhbnNmb3JtT3B0aW9uc1xuICAgIHNhc3M6IFN5bmNPcHRpb25zXG59XG5cbmZ1bmN0aW9uIGxvYWRDb25maWcocGF0aG5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUocGF0aC5yZXNvbHZlKHBhdGhuYW1lKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gbG9hZCBjb25maWcgJyR7cGF0aG5hbWV9JyBmcm9tICcke3Byb2Nlc3MuY3dkKCl9JywgJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbmZpZyhwYXRobmFtZTogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUucmVzb2x2ZShwYXRoLnJlc29sdmUocGF0aG5hbWUpKTtcbiAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYXNzaWduQ29uZmlnPFY+KHRhcmdldDogViwgc291cmNlOiBhbnkpIHtcbiAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQgJiYgc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBBcnJheSAmJiBzb3VyY2UgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gbmV3IFNldCh0YXJnZXQpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIG1lcmdlZC5hZGQoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXQubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKC4uLm1lcmdlZCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0IGluc3RhbmNlb2YgT2JqZWN0ICYmIHNvdXJjZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXM8b2JqZWN0Pihzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldFtrXSAmJiAodi5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0IHx8IHYuY29uc3RydWN0b3IgPT09IEFycmF5KSkge1xuICAgICAgICAgICAgICAgICAgICBhc3NpZ25Db25maWcodGFyZ2V0W2tdLCB2KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba10gPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbG9hZFBsdWdpbihtb2R1bGUpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZShgJHttb2R1bGV9L2VzbmV4dC1zZXJ2ZXIucGx1Z2luYCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nLmVycm9yKFwicGx1Z2luXCIsIG1vZHVsZSwgXCJsb2FkIGZhaWxlZFwiLCBlcnJvcik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGxvYWQgcGx1Z2luICcke21vZHVsZX0nIGZyb20gJyR7cHJvY2Vzcy5jd2QoKX0nYCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzdGF0RGlyZWN0b3J5KHBhdGhuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZzLnN0YXRTeW5jKHBhdGhuYW1lKTtcbiAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5ICcke3BhdGhuYW1lfSdgKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVEaXJlY3RvcnkobmFtZSkge1xuICAgIGNvbnN0IHBhdGhuYW1lID0gcGF0aC5yZXNvbHZlKG5hbWUpO1xuICAgIGlmICghc3RhdERpcmVjdG9yeShwYXRobmFtZSkuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVOT0RJUjogbm90IGEgZGlyZWN0b3J5ICcke3BhdGhuYW1lfSdgKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGhuYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdE9wdGlvbnMoYXJnczogQXJncyk6IEVTTmV4dE9wdGlvbnMge1xuXG4gICAgY29uc3QgYmFzZURpciA9IHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsIFwiLi5cIik7XG4gICAgY29uc3Qgcm9vdERpciA9IGFyZ3Mucm9vdCA/IHJlc29sdmVEaXJlY3RvcnkoYXJncy5yb290KSA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgICBjb25zdCByZWFkVGV4dEZpbGVTeW5jID0gKGZpbGVuYW1lKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKHBhdGgucmVzb2x2ZShyb290RGlyLCBmaWxlbmFtZSksIFwidXRmLThcIik7XG4gICAgICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMocGF0aC5yZXNvbHZlKGJhc2VEaXIsIGZpbGVuYW1lKSwgXCJ1dGYtOFwiKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIHJvb3REaXIsXG4gICAgICAgIGxvZzoge1xuICAgICAgICAgICAgbGV2ZWw6IFwiaW5mb1wiXG4gICAgICAgIH0sXG4gICAgICAgIGh0dHAyOiBcInB1c2hcIixcbiAgICAgICAgc2VydmVyOiB7XG4gICAgICAgICAgICBwcm90b2NvbDogXCJodHRwc1wiLFxuICAgICAgICAgICAgaG9zdDogXCJsb2NhbGhvc3RcIixcbiAgICAgICAgICAgIHBvcnQ6IDMwMDAsXG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgZ2V0IGtleSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRUZXh0RmlsZVN5bmMoXCJjZXJ0L2xvY2FsaG9zdC5rZXlcIik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXQgY2VydCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRUZXh0RmlsZVN5bmMoXCJjZXJ0L2xvY2FsaG9zdC5jcnRcIik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhbGxvd0hUVFAxOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlc291cmNlczogcGF0aC5yZXNvbHZlKGJhc2VEaXIsIFwicmVzb3VyY2VzXCIpLFxuICAgICAgICB3YXRjaGVyOiB7XG4gICAgICAgICAgICBjd2Q6IHJvb3REaXIsXG4gICAgICAgICAgICBhdG9taWM6IGZhbHNlLFxuICAgICAgICAgICAgaWdub3JlZDogW1xuICAgICAgICAgICAgICAgIFwibm9kZV9tb2R1bGVzLyoqXCIsXG4gICAgICAgICAgICAgICAgXCJ3ZWJfbW9kdWxlcy8qKlwiXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHJvdXRlcjoge1xuICAgICAgICAgICAgaWdub3JlVHJhaWxpbmdTbGFzaDogdHJ1ZSxcbiAgICAgICAgICAgIGFsbG93VW5zYWZlUmVnZXg6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgbWlkZGxld2FyZTogW10sXG4gICAgICAgIHByb3h5OiB7XG4gICAgICAgICAgICBcIi9hcGlcIjoge3RhcmdldDogXCJodHRwOi8vbG9jYWxob3N0OjkwMDBcIn1cbiAgICAgICAgfSxcbiAgICAgICAgY29yczoge1xuICAgICAgICAgICAgb3JpZ2luOiBcIipcIixcbiAgICAgICAgICAgIG1ldGhvZHM6IFwiR0VULCBIRUFELCBQVVQsIFBPU1QsIERFTEVURSwgUEFUQ0hcIixcbiAgICAgICAgICAgIGFsbG93ZWRIZWFkZXJzOiBcIlgtUmVxdWVzdGVkLVdpdGgsIEFjY2VwdCwgQ29udGVudC1UeXBlXCIsXG4gICAgICAgICAgICBjcmVkZW50aWFsczogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBjYWNoZTogdHJ1ZSxcbiAgICAgICAgZGVmbGF0ZTogdHJ1ZSxcbiAgICAgICAgZXRhZzoge1xuICAgICAgICAgICAgd2VhazogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgbW91bnQ6IHtcbiAgICAgICAgICAgIFwiL1wiOiByb290RGlyXG4gICAgICAgIH0sXG4gICAgICAgIGJhYmVsOiB7XG4gICAgICAgICAgICBiYWJlbHJjOiB0cnVlLFxuICAgICAgICAgICAgY2FsbGVyOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJlc25leHQtc2VydmVyXCIsXG4gICAgICAgICAgICAgICAgc3VwcG9ydHNTdGF0aWNFU006IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzb3VyY2VUeXBlOiBcIm1vZHVsZVwiLFxuICAgICAgICAgICAgc291cmNlTWFwczogdHJ1ZSxcbiAgICAgICAgICAgIHBsdWdpbnM6IFtcbiAgICAgICAgICAgICAgICBbXCJAYmFiZWwvcGx1Z2luLXN5bnRheC1pbXBvcnQtbWV0YVwiXSxcbiAgICAgICAgICAgICAgICBbXCJAYmFiZWwvcGx1Z2luLXRyYW5zZm9ybS1ydW50aW1lXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgXCJjb3JlanNcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIFwiaGVscGVyc1wiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBcInJlZ2VuZXJhdG9yXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBcInVzZUVTTW9kdWxlc1wiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBcImFic29sdXRlUnVudGltZVwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ2ZXJzaW9uXCI6IFwiNy4xMC41XCJcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBzYXNzOiB7XG4gICAgICAgICAgICBleHRlbnNpb25zOiBbXCIuc2Nzc1wiLCBcIi5jc3NcIiwgXCIuc2Fzc1wiXSxcbiAgICAgICAgICAgIG91dHB1dFN0eWxlOiBcImV4cGFuZGVkXCJcbiAgICAgICAgfVxuICAgIH0sIHJlcXVpcmUoXCJlc25leHQtd2ViLW1vZHVsZXMvd2ViLW1vZHVsZXMuY29uZmlnLmpzXCIpKTtcbn1cblxuZXhwb3J0IHR5cGUgQXJncyA9IHtcbiAgICBjb25maWc/OiBzdHJpbmdcbiAgICByb290Pzogc3RyaW5nXG4gICAgbW9kdWxlPzogc3RyaW5nIHwgc3RyaW5nW11cbiAgICBkZWJ1Zz86IGJvb2xlYW5cbiAgICBwcm9kdWN0aW9uPzogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29uZmlndXJlKGFyZ3M6IEFyZ3MgPSB7fSwgb3ZlcnJpZGU/KTogUmVhZG9ubHk8RVNOZXh0T3B0aW9ucz4ge1xuXG4gICAgbGV0IG9wdGlvbnM6IEVTTmV4dE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucyhhcmdzKTtcblxuICAgIGlmIChhcmdzLmNvbmZpZykge1xuICAgICAgICBhc3NpZ25Db25maWcob3B0aW9ucywgbG9hZENvbmZpZyhhcmdzLmNvbmZpZykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJvb3RDb25maWcgPSByZXNvbHZlQ29uZmlnKHBhdGguam9pbihvcHRpb25zLnJvb3REaXIsIFwiZXNuZXh0LXNlcnZlci5jb25maWdcIikpO1xuICAgICAgICBjb25zdCBsb2NhbENvbmZpZyA9IHJlc29sdmVDb25maWcoXCJlc25leHQtc2VydmVyLmNvbmZpZ1wiKTtcbiAgICAgICAgaWYgKHJvb3RDb25maWcpIHtcbiAgICAgICAgICAgIGlmIChsb2NhbENvbmZpZyAhPT0gcm9vdENvbmZpZykge1xuICAgICAgICAgICAgICAgIGFzc2lnbkNvbmZpZyhvcHRpb25zLCBsb2FkQ29uZmlnKHJvb3RDb25maWcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZy5kZWJ1Zyhgbm8gY29uZmlnIGZvdW5kIGluICcke29wdGlvbnMucm9vdERpcn0nYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsQ29uZmlnKSB7XG4gICAgICAgICAgICBhc3NpZ25Db25maWcob3B0aW9ucywgbG9hZENvbmZpZyhsb2NhbENvbmZpZykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nLmRlYnVnKGBubyBjb25maWcgZm91bmQgaW4gJyR7cHJvY2Vzcy5jd2QoKX0nYCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgYXNzaWduQ29uZmlnKG9wdGlvbnMsIG92ZXJyaWRlKTtcbiAgICB9XG5cbiAgICBpZiAoYXJncy5tb2R1bGUpIHtcbiAgICAgICAgY29uc3QgbW9kdWxlcyA9IEFycmF5LmlzQXJyYXkoYXJncy5tb2R1bGUpID8gYXJncy5tb2R1bGUgOiBbYXJncy5tb2R1bGVdO1xuICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBtb2R1bGVzKSB7XG4gICAgICAgICAgICBhc3NpZ25Db25maWcob3B0aW9ucywgbG9hZFBsdWdpbihtb2R1bGUpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmxvZykge1xuICAgICAgICBPYmplY3QuYXNzaWduKGxvZywgb3B0aW9ucy5sb2cpO1xuICAgIH1cblxuICAgIGlmIChhcmdzLmRlYnVnKSB7XG4gICAgICAgIGxvZy5sZXZlbCA9IFwiZGVidWdcIjtcbiAgICB9XG5cbiAgICBsb2cuZGVidWcoXCJjb25maWd1cmVkOlwiLCBvcHRpb25zKTtcblxuICAgIHJldHVybiBvcHRpb25zO1xufVxuIl19