"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useResourceProvider = exports.NO_QUERY = exports.NO_LINKS = void 0;
const chalk_1 = __importDefault(require("chalk"));
const etag_1 = __importDefault(require("etag"));
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const pico_memoize_1 = __importDefault(require("pico-memoize"));
const tiny_node_logger_1 = __importDefault(require("tiny-node-logger"));
const hmr_server_1 = require("../hmr-server");
const transformers_1 = require("../transformers");
const mime_types_1 = require("../util/mime-types");
const zlib_1 = require("../util/zlib");
const router_1 = require("./router");
exports.NO_LINKS = Object.freeze([]);
exports.NO_QUERY = Object.freeze({});
/*
 * NOTE: cache & hmr have two very distinct roles, cache won't invalidate an entry because the dependents
 */
exports.useResourceProvider = pico_memoize_1.default(function (options, watcher) {
    const cache = new Map();
    const watched = new Map();
    const hmr = hmr_server_1.useHotModuleReplacement(options);
    function store(url, resource) {
        if (options.cache) {
            cache.set(url, resource);
            watch(resource.filename, url);
            if (resource.watch) {
                for (const watched of resource.watch)
                    watch(watched, url);
            }
        }
        if (hmr.engine && resource.links) {
            for (const link of resource.links) {
                hmr.engine.addRelationship(url, link);
            }
        }
    }
    function discard(url, resource) {
        if (cache) {
            cache.delete(url);
        }
        if (hmr.engine && resource.links) {
            for (const link of resource.links) {
                hmr.engine.removeRelationship(url, link);
            }
        }
    }
    function watch(filename, url) {
        const pathname = path_1.default.relative(options.rootDir, filename);
        let urls = watched.get(pathname);
        if (urls) {
            urls.add(url);
        }
        else {
            urls = new Set().add(url);
            watched.set(pathname, urls);
            watcher.add(pathname);
        }
        return urls;
    }
    function unwatch(path) {
        watched.delete(path);
        watcher.unwatch(path);
    }
    function updateOrBubble(url, visited) {
        if (visited.has(url)) {
            return;
        }
        const node = hmr.engine.getEntry(url);
        const isBubbled = visited.size > 0;
        if (node && node.isHmrEnabled) {
            hmr.engine.broadcastMessage({ type: 'update', url, bubbled: isBubbled });
        }
        visited.add(url);
        if (node && node.isHmrAccepted) {
            // Found a boundary, no bubbling needed
        }
        else if (node && node.dependents.size > 0) {
            node.dependents.forEach((dep) => {
                hmr.engine.markEntryForReplacement(node, true);
                updateOrBubble(dep, visited);
            });
        }
        else {
            // We've reached the top, trigger a full page refresh
            hmr.engine.broadcastMessage({ type: 'reload' });
        }
    }
    watcher.on("change", function (path) {
        const urls = watched.get(path);
        if (urls)
            for (const url of urls) {
                reload(url, path);
                if (hmr.engine.getEntry(url)) {
                    hmr.engine.broadcastMessage({ type: 'update', url, bubbled: false });
                    // updateOrBubble(url, new Set());
                    return;
                }
            }
    });
    watcher.on("unlink", function (event, path) {
        const urls = watched.get(path);
        if (urls)
            for (const url of urls) {
                tiny_node_logger_1.default.debug("invalidate", path, "flush", url);
                cache.delete(url);
            }
        unwatch(path);
    });
    async function reload(url, path) {
        const resource = cache.get(url);
        if (resource) {
            cache.set(url, Promise.resolve(resource).then(async (resource) => {
                const stats = await fs_1.promises.stat(resource.filename);
                resource.content = await fs_1.promises.readFile(resource.filename);
                resource.headers["content-type"] = mime_types_1.contentType(resource.filename);
                resource.headers["content-length"] = stats.size;
                resource.headers["last-modified"] = stats.mtime.toUTCString();
                return pipeline(resource);
            }).then(resource => {
                cache.set(url, resource);
                return resource;
            }));
        }
        else {
            tiny_node_logger_1.default.warn("no cache entry for:", url);
            unwatch(path);
        }
    }
    const { route } = router_1.useRouter(options);
    const { shouldTransform, transformContent } = transformers_1.useTransformers(options);
    const { applyCompression } = zlib_1.useZlib(options);
    /**
     *          _            _ _
     *         (_)          | (_)
     *    _ __  _ _ __   ___| |_ _ __   ___
     *   | '_ \| | '_ \ / _ \ | | '_ \ / _ \
     *   | |_) | | |_) |  __/ | | | | |  __/
     *   | .__/|_| .__/ \___|_|_|_| |_|\___|
     *   | |     | |
     *   |_|     |_|
     *
     * @param url
     */
    async function provideResource(url) {
        const resource = await route(url);
        return pipeline(resource);
    }
    async function pipeline(resource) {
        if (shouldTransform(resource)) {
            const sourceMap = await transformContent(resource);
            if (sourceMap) {
                storeSourceMap(resource.filename, resource.pathname, resource.query, sourceMap);
            }
        }
        await etagHeader(resource);
        if (options.encoding) {
            await compressContent(resource);
        }
        return resource;
    }
    function storeSourceMap(filename, pathname, query, map) {
        const content = applyCompression(JSON.stringify(map), "deflate");
        const sourceMapUrl = pathname + ".map";
        const sourceMapFilename = filename + ".map";
        cache.set(sourceMapUrl, {
            filename: sourceMapFilename,
            pathname: sourceMapUrl,
            query: query,
            content: content,
            headers: {
                "content-type": mime_types_1.JSON_CONTENT_TYPE,
                "content-length": content.length,
                "content-encoding": "deflate",
                "last-modified": new Date().toUTCString(),
                "cache-control": "no-cache"
            },
            links: exports.NO_LINKS
        });
    }
    async function etagHeader({ headers, pathname }) {
        headers["etag"] = etag_1.default(`${pathname} ${headers["content-length"]} ${headers["last-modified"]}`, options.etag);
    }
    async function compressContent(resource) {
        try {
            resource.content = applyCompression(resource.content);
            resource.headers = {
                ...(resource.headers),
                "content-length": resource.content.length,
                "content-encoding": options.encoding
            };
        }
        catch (err) {
            tiny_node_logger_1.default.error(`failed to deflate resource: ${resource.filename}`, err);
        }
    }
    return {
        async provideResource(url) {
            let resource = cache.get(url);
            if (resource) {
                tiny_node_logger_1.default.debug("retrieved from cache:", chalk_1.default.magenta(url));
            }
            else {
                resource = provideResource(url).then(resource => {
                    store(url, resource);
                    return resource;
                }).finally(function () {
                    if (!options.cache) {
                        cache.delete(url);
                    }
                });
                cache.set(url, resource);
            }
            return resource;
        }
    };
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzb3VyY2UtcHJvdmlkZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvcHJvdmlkZXJzL3Jlc291cmNlLXByb3ZpZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLGtEQUEwQjtBQUUxQixnREFBd0I7QUFDeEIsMkJBQWtDO0FBRWxDLGdEQUF3QjtBQUN4QixnRUFBbUM7QUFDbkMsd0VBQW1DO0FBRW5DLDhDQUFzRDtBQUN0RCxrREFBMkQ7QUFDM0QsbURBQWtFO0FBQ2xFLHVDQUFxQztBQUNyQyxxQ0FBbUM7QUFnQnRCLFFBQUEsUUFBUSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDN0IsUUFBQSxRQUFRLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUUxQzs7R0FFRztBQUVVLFFBQUEsbUJBQW1CLEdBQUcsc0JBQU8sQ0FBQyxVQUFVLE9BQXNCLEVBQUUsT0FBa0I7SUFFM0YsTUFBTSxLQUFLLEdBQUcsSUFBSSxHQUFHLEVBQXdDLENBQUM7SUFDOUQsTUFBTSxPQUFPLEdBQUcsSUFBSSxHQUFHLEVBQXVCLENBQUM7SUFDL0MsTUFBTSxHQUFHLEdBQUcsb0NBQXVCLENBQUMsT0FBTyxDQUFDLENBQUM7SUFFN0MsU0FBUyxLQUFLLENBQUMsR0FBVyxFQUFFLFFBQWtCO1FBRTFDLElBQUksT0FBTyxDQUFDLEtBQUssRUFBRTtZQUNmLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBQ3pCLEtBQUssQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBQzlCLElBQUksUUFBUSxDQUFDLEtBQUssRUFBRTtnQkFDaEIsS0FBSyxNQUFNLE9BQU8sSUFBSSxRQUFRLENBQUMsS0FBSztvQkFBRSxLQUFLLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxDQUFDO2FBQzdEO1NBQ0o7UUFFRCxJQUFJ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UUFBUSxFQUFFO2dCQUNWLDBCQUFHLENBQUMsS0FBSyxDQUFDLHVCQUF1QixFQUFFLGVBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQzthQUMxRDtpQkFBTTtnQkFDSCxRQUFRLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRTtvQkFDNUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsQ0FBQztvQkFDckIsT0FBTyxRQUFRLENBQUM7Z0JBQ3BCLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQztvQkFDUCxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRTt3QkFDaEIsS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztxQkFDckI7Z0JBQ0wsQ0FBQyxDQUFDLENBQUM7Z0JBQ0gsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUM7YUFDNUI7WUFDRCxPQUFPLFFBQVEsQ0FBQztRQUNwQixDQUFDO0tBQ0osQ0FBQztBQUNOLENBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNoYWxrIGZyb20gXCJjaGFsa1wiO1xuaW1wb3J0IHtGU1dhdGNoZXJ9IGZyb20gXCJjaG9raWRhclwiO1xuaW1wb3J0IGV0YWcgZnJvbSBcImV0YWdcIjtcbmltcG9ydCB7cHJvbWlzZXMgYXMgZnN9IGZyb20gXCJmc1wiO1xuaW1wb3J0IHtPdXRnb2luZ0h0dHBIZWFkZXJzfSBmcm9tIFwiaHR0cFwiO1xuaW1wb3J0IHBhdGggZnJvbSBcInBhdGhcIjtcbmltcG9ydCBtZW1vaXplIGZyb20gXCJwaWNvLW1lbW9pemVcIjtcbmltcG9ydCBsb2cgZnJvbSBcInRpbnktbm9kZS1sb2dnZXJcIjtcbmltcG9ydCB7RVNOZXh0T3B0aW9uc30gZnJvbSBcIi4uL2NvbmZpZ3VyZVwiO1xuaW1wb3J0IHt1c2VIb3RNb2R1bGVSZXBsYWNlbWVudH0gZnJvbSBcIi4uL2htci1zZXJ2ZXJcIjtcbmltcG9ydCB7U291cmNlTWFwLCB1c2VUcmFuc2Zvcm1lcnN9IGZyb20gXCIuLi90cmFuc2Zvcm1lcnNcIjtcbmltcG9ydCB7Y29udGVudFR5cGUsIEpTT05fQ09OVEVOVF9UWVBFfSBmcm9tIFwiLi4vdXRpbC9taW1lLXR5cGVzXCI7XG5pbXBvcnQge3VzZVpsaWJ9IGZyb20gXCIuLi91dGlsL3psaWJcIjtcbmltcG9ydCB7dXNlUm91dGVyfSBmcm9tIFwiLi9yb3V0ZXJcIjtcblxuXG5leHBvcnQgdHlwZSBRdWVyeSA9IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB9O1xuXG5leHBvcnQgdHlwZSBSZXNvdXJjZSA9IHtcbiAgICBwYXRobmFtZTogc3RyaW5nXG4gICAgcXVlcnk6IFF1ZXJ5XG4gICAgZmlsZW5hbWU6IHN0cmluZ1xuICAgIGNvbnRlbnQ6IHN0cmluZyB8IEJ1ZmZlclxuICAgIGhlYWRlcnM6IE91dGdvaW5nSHR0cEhlYWRlcnNcbiAgICBsaW5rczogcmVhZG9ubHkgc3RyaW5nW11cbiAgICB3YXRjaD86IEl0ZXJhYmxlPHN0cmluZz5cbiAgICBvbmNoYW5nZT86ICgpID0+IHZvaWRcbn1cblxuZXhwb3J0IGNvbnN0IE5PX0xJTktTID0gT2JqZWN0LmZyZWV6ZShbXSk7XG5leHBvcnQgY29uc3QgTk9fUVVFUlkgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLypcbiAqIE5PVEU6IGNhY2hlICYgaG1yIGhhdmUgdHdvIHZlcnkgZGlzdGluY3Qgcm9sZXMsIGNhY2hlIHdvbid0IGludmFsaWRhdGUgYW4gZW50cnkgYmVjYXVzZSB0aGUgZGVwZW5kZW50c1xuICovXG5cbmV4cG9ydCBjb25zdCB1c2VSZXNvdXJjZVByb3ZpZGVyID0gbWVtb2l6ZShmdW5jdGlvbiAob3B0aW9uczogRVNOZXh0T3B0aW9ucywgd2F0Y2hlcjogRlNXYXRjaGVyKSB7XG5cbiAgICBjb25zdCBjYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBSZXNvdXJjZSB8IFByb21pc2U8UmVzb3VyY2U+PigpO1xuICAgIGNvbnN0IHdhdGNoZWQgPSBuZXcgTWFwPHN0cmluZywgU2V0PHN0cmluZz4+KCk7XG4gICAgY29uc3QgaG1yID0gdXNlSG90TW9kdWxlUmVwbGFjZW1lbnQob3B0aW9ucyk7XG5cbiAgICBmdW5jdGlvbiBzdG9yZSh1cmw6IHN0cmluZywgcmVzb3VyY2U6IFJlc291cmNlKSB7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuY2FjaGUpIHtcbiAgICAgICAgICAgIGNhY2hlLnNldCh1cmwsIHJlc291cmNlKTtcbiAgICAgICAgICAgIHdhdGNoKHJlc291cmNlLmZpbGVuYW1lLCB1cmwpO1xuICAgICAgICAgICAgaWYgKHJlc291cmNlLndhdGNoKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB3YXRjaGVkIG9mIHJlc291cmNlLndhdGNoKSB3YXRjaCh3YXRjaGVkLCB1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhtci5lbmdpbmUgJiYgcmVzb3VyY2UubGlua3MpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGluayBvZiByZXNvdXJjZS5saW5rcykge1xuICAgICAgICAgICAgICAgIGhtci5lbmdpbmUuYWRkUmVsYXRpb25zaGlwKHVybCwgbGluayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaXNjYXJkKHVybDogc3RyaW5nLCByZXNvdXJjZTogUmVzb3VyY2UpIHtcbiAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgICBjYWNoZS5kZWxldGUodXJsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG1yLmVuZ2luZSAmJiByZXNvdXJjZS5saW5rcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBsaW5rIG9mIHJlc291cmNlLmxpbmtzKSB7XG4gICAgICAgICAgICAgICAgaG1yLmVuZ2luZS5yZW1vdmVSZWxhdGlvbnNoaXAodXJsLCBsaW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhdGNoKGZpbGVuYW1lLCB1cmwpOiBTZXQ8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IHBhdGhuYW1lID0gcGF0aC5yZWxhdGl2ZShvcHRpb25zLnJvb3REaXIsIGZpbGVuYW1lKTtcbiAgICAgICAgbGV0IHVybHMgPSB3YXRjaGVkLmdldChwYXRobmFtZSk7XG4gICAgICAgIGlmICh1cmxzKSB7XG4gICAgICAgICAgICB1cmxzLmFkZCh1cmwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXJscyA9IG5ldyBTZXQ8c3RyaW5nPigpLmFkZCh1cmwpO1xuICAgICAgICAgICAgd2F0Y2hlZC5zZXQocGF0aG5hbWUsIHVybHMpO1xuICAgICAgICAgICAgd2F0Y2hlci5hZGQocGF0aG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmxzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVud2F0Y2gocGF0aCkge1xuICAgICAgICB3YXRjaGVkLmRlbGV0ZShwYXRoKTtcbiAgICAgICAgd2F0Y2hlci51bndhdGNoKHBhdGgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZU9yQnViYmxlKHVybDogc3RyaW5nLCB2aXNpdGVkOiBTZXQ8c3RyaW5nPikge1xuICAgICAgICBpZiAodmlzaXRlZC5oYXModXJsKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGUgPSBobXIuZW5naW5lIS5nZXRFbnRyeSh1cmwpO1xuICAgICAgICBjb25zdCBpc0J1YmJsZWQgPSB2aXNpdGVkLnNpemUgPiAwO1xuICAgICAgICBpZiAobm9kZSAmJiBub2RlLmlzSG1yRW5hYmxlZCkge1xuICAgICAgICAgICAgaG1yLmVuZ2luZSEuYnJvYWRjYXN0TWVzc2FnZSh7dHlwZTogJ3VwZGF0ZScsIHVybCwgYnViYmxlZDogaXNCdWJibGVkfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXRlZC5hZGQodXJsKTtcbiAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5pc0htckFjY2VwdGVkKSB7XG4gICAgICAgICAgICAvLyBGb3VuZCBhIGJvdW5kYXJ5LCBubyBidWJibGluZyBuZWVkZWRcbiAgICAgICAgfSBlbHNlIGlmIChub2RlICYmIG5vZGUuZGVwZW5kZW50cy5zaXplID4gMCkge1xuICAgICAgICAgICAgbm9kZS5kZXBlbmRlbnRzLmZvckVhY2goKGRlcCkgPT4ge1xuICAgICAgICAgICAgICAgIGhtci5lbmdpbmUhLm1hcmtFbnRyeUZvclJlcGxhY2VtZW50KG5vZGUsIHRydWUpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZU9yQnViYmxlKGRlcCwgdmlzaXRlZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIHRvcCwgdHJpZ2dlciBhIGZ1bGwgcGFnZSByZWZyZXNoXG4gICAgICAgICAgICBobXIuZW5naW5lIS5icm9hZGNhc3RNZXNzYWdlKHt0eXBlOiAncmVsb2FkJ30pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgd2F0Y2hlci5vbihcImNoYW5nZVwiLCBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICBjb25zdCB1cmxzID0gd2F0Y2hlZC5nZXQocGF0aCk7XG4gICAgICAgIGlmICh1cmxzKSBmb3IgKGNvbnN0IHVybCBvZiB1cmxzKSB7XG4gICAgICAgICAgICByZWxvYWQodXJsLCBwYXRoKTtcbiAgICAgICAgICAgIGlmIChobXIuZW5naW5lIS5nZXRFbnRyeSh1cmwpKSB7XG4gICAgICAgICAgICAgICAgaG1yLmVuZ2luZSEuYnJvYWRjYXN0TWVzc2FnZSh7dHlwZTogJ3VwZGF0ZScsIHVybCwgYnViYmxlZDogZmFsc2V9KTtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGVPckJ1YmJsZSh1cmwsIG5ldyBTZXQoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB3YXRjaGVyLm9uKFwidW5saW5rXCIsIGZ1bmN0aW9uIChldmVudCwgcGF0aCkge1xuICAgICAgICBjb25zdCB1cmxzID0gd2F0Y2hlZC5nZXQocGF0aCk7XG4gICAgICAgIGlmICh1cmxzKSBmb3IgKGNvbnN0IHVybCBvZiB1cmxzKSB7XG4gICAgICAgICAgICBsb2cuZGVidWcoXCJpbnZhbGlkYXRlXCIsIHBhdGgsIFwiZmx1c2hcIiwgdXJsKTtcbiAgICAgICAgICAgIGNhY2hlLmRlbGV0ZSh1cmwpO1xuICAgICAgICB9XG4gICAgICAgIHVud2F0Y2gocGF0aCk7XG4gICAgfSk7XG5cbiAgICBhc3luYyBmdW5jdGlvbiByZWxvYWQodXJsOnN0cmluZywgcGF0aDpzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgcmVzb3VyY2UgPSBjYWNoZS5nZXQodXJsKTtcbiAgICAgICAgaWYgKHJlc291cmNlKSB7XG4gICAgICAgICAgICBjYWNoZS5zZXQodXJsLCBQcm9taXNlLnJlc29sdmUocmVzb3VyY2UpLnRoZW4oYXN5bmMgcmVzb3VyY2UgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgZnMuc3RhdChyZXNvdXJjZS5maWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgcmVzb3VyY2UuY29udGVudCA9IGF3YWl0IGZzLnJlYWRGaWxlKHJlc291cmNlLmZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICByZXNvdXJjZS5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdID0gY29udGVudFR5cGUocmVzb3VyY2UuZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgIHJlc291cmNlLmhlYWRlcnNbXCJjb250ZW50LWxlbmd0aFwiXSA9IHN0YXRzLnNpemU7XG4gICAgICAgICAgICAgICAgcmVzb3VyY2UuaGVhZGVyc1tcImxhc3QtbW9kaWZpZWRcIl0gPSBzdGF0cy5tdGltZS50b1VUQ1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwaXBlbGluZShyZXNvdXJjZSk7XG4gICAgICAgICAgICB9KS50aGVuKHJlc291cmNlID0+IHtcbiAgICAgICAgICAgICAgICBjYWNoZS5zZXQodXJsLCByZXNvdXJjZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc291cmNlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nLndhcm4oXCJubyBjYWNoZSBlbnRyeSBmb3I6XCIsIHVybCk7XG4gICAgICAgICAgICB1bndhdGNoKHBhdGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qge3JvdXRlfSA9IHVzZVJvdXRlcihvcHRpb25zKTtcbiAgICBjb25zdCB7c2hvdWxkVHJhbnNmb3JtLCB0cmFuc2Zvcm1Db250ZW50fSA9IHVzZVRyYW5zZm9ybWVycyhvcHRpb25zKTtcbiAgICBjb25zdCB7YXBwbHlDb21wcmVzc2lvbn0gPSB1c2VabGliKG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogICAgICAgICAgXyAgICAgICAgICAgIF8gX1xuICAgICAqICAgICAgICAgKF8pICAgICAgICAgIHwgKF8pXG4gICAgICogICAgXyBfXyAgXyBfIF9fICAgX19ffCB8XyBfIF9fICAgX19fXG4gICAgICogICB8ICdfIFxcfCB8ICdfIFxcIC8gXyBcXCB8IHwgJ18gXFwgLyBfIFxcXG4gICAgICogICB8IHxfKSB8IHwgfF8pIHwgIF9fLyB8IHwgfCB8IHwgIF9fL1xuICAgICAqICAgfCAuX18vfF98IC5fXy8gXFxfX198X3xffF98IHxffFxcX19ffFxuICAgICAqICAgfCB8ICAgICB8IHxcbiAgICAgKiAgIHxffCAgICAgfF98XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXJsXG4gICAgICovXG4gICAgYXN5bmMgZnVuY3Rpb24gcHJvdmlkZVJlc291cmNlKHVybDogc3RyaW5nKTogUHJvbWlzZTxSZXNvdXJjZT4ge1xuICAgICAgICBjb25zdCByZXNvdXJjZSA9IGF3YWl0IHJvdXRlKHVybCk7XG4gICAgICAgIHJldHVybiBwaXBlbGluZShyZXNvdXJjZSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcGlwZWxpbmUocmVzb3VyY2U6IFJlc291cmNlKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFuc2Zvcm0ocmVzb3VyY2UpKSB7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VNYXAgPSBhd2FpdCB0cmFuc2Zvcm1Db250ZW50KHJlc291cmNlKTtcbiAgICAgICAgICAgIGlmIChzb3VyY2VNYXApIHtcbiAgICAgICAgICAgICAgICBzdG9yZVNvdXJjZU1hcChyZXNvdXJjZS5maWxlbmFtZSwgcmVzb3VyY2UucGF0aG5hbWUsIHJlc291cmNlLnF1ZXJ5LCBzb3VyY2VNYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGV0YWdIZWFkZXIocmVzb3VyY2UpO1xuICAgICAgICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgICAgICAgICAgYXdhaXQgY29tcHJlc3NDb250ZW50KHJlc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb3VyY2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RvcmVTb3VyY2VNYXAoZmlsZW5hbWU6IHN0cmluZywgcGF0aG5hbWU6IHN0cmluZywgcXVlcnk6IFF1ZXJ5LCBtYXA/OiBTb3VyY2VNYXAgfCBudWxsKSB7XG5cbiAgICAgICAgY29uc3QgY29udGVudCA9IGFwcGx5Q29tcHJlc3Npb24oSlNPTi5zdHJpbmdpZnkobWFwKSwgXCJkZWZsYXRlXCIpO1xuICAgICAgICBjb25zdCBzb3VyY2VNYXBVcmwgPSBwYXRobmFtZSArIFwiLm1hcFwiO1xuICAgICAgICBjb25zdCBzb3VyY2VNYXBGaWxlbmFtZSA9IGZpbGVuYW1lICsgXCIubWFwXCI7XG5cbiAgICAgICAgY2FjaGUuc2V0KHNvdXJjZU1hcFVybCwge1xuICAgICAgICAgICAgZmlsZW5hbWU6IHNvdXJjZU1hcEZpbGVuYW1lLFxuICAgICAgICAgICAgcGF0aG5hbWU6IHNvdXJjZU1hcFVybCxcbiAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJjb250ZW50LXR5cGVcIjogSlNPTl9DT05URU5UX1RZUEUsXG4gICAgICAgICAgICAgICAgXCJjb250ZW50LWxlbmd0aFwiOiBjb250ZW50Lmxlbmd0aCwgLy8gQnVmZmVyLmJ5dGVMZW5ndGgoY29udGVudCksXG4gICAgICAgICAgICAgICAgXCJjb250ZW50LWVuY29kaW5nXCI6IFwiZGVmbGF0ZVwiLFxuICAgICAgICAgICAgICAgIFwibGFzdC1tb2RpZmllZFwiOiBuZXcgRGF0ZSgpLnRvVVRDU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgXCJjYWNoZS1jb250cm9sXCI6IFwibm8tY2FjaGVcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbmtzOiBOT19MSU5LU1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBldGFnSGVhZGVyKHtoZWFkZXJzLCBwYXRobmFtZX06IFJlc291cmNlKSB7XG4gICAgICAgIGhlYWRlcnNbXCJldGFnXCJdID0gZXRhZyhgJHtwYXRobmFtZX0gJHtoZWFkZXJzW1wiY29udGVudC1sZW5ndGhcIl19ICR7aGVhZGVyc1tcImxhc3QtbW9kaWZpZWRcIl19YCwgb3B0aW9ucy5ldGFnKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBjb21wcmVzc0NvbnRlbnQocmVzb3VyY2U6IFJlc291cmNlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNvdXJjZS5jb250ZW50ID0gYXBwbHlDb21wcmVzc2lvbihyZXNvdXJjZS5jb250ZW50KTtcbiAgICAgICAgICAgIHJlc291cmNlLmhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgLi4uKHJlc291cmNlLmhlYWRlcnMpLFxuICAgICAgICAgICAgICAgIFwiY29udGVudC1sZW5ndGhcIjogcmVzb3VyY2UuY29udGVudC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgXCJjb250ZW50LWVuY29kaW5nXCI6IG9wdGlvbnMuZW5jb2RpbmdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbG9nLmVycm9yKGBmYWlsZWQgdG8gZGVmbGF0ZSByZXNvdXJjZTogJHtyZXNvdXJjZS5maWxlbmFtZX1gLCBlcnIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXN5bmMgcHJvdmlkZVJlc291cmNlKHVybDogc3RyaW5nKTogUHJvbWlzZTxSZXNvdXJjZT4ge1xuICAgICAgICAgICAgbGV0IHJlc291cmNlID0gY2FjaGUuZ2V0KHVybCk7XG4gICAgICAgICAgICBpZiAocmVzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBsb2cuZGVidWcoXCJyZXRyaWV2ZWQgZnJvbSBjYWNoZTpcIiwgY2hhbGsubWFnZW50YSh1cmwpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb3VyY2UgPSBwcm92aWRlUmVzb3VyY2UodXJsKS50aGVuKHJlc291cmNlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUodXJsLCByZXNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvdXJjZTtcbiAgICAgICAgICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5kZWxldGUodXJsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNhY2hlLnNldCh1cmwsIHJlc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNvdXJjZTtcbiAgICAgICAgfVxuICAgIH07XG59KTtcblxuIl19